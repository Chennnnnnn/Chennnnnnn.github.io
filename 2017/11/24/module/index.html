<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>模块化 | Chennnn</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">模块化</h1><a id="logo" href="/.">Chennnn</a><p class="description">在安静中，不慌不忙地坚强</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">模块化</h1><div class="post-meta">Nov 24, 2017<span> | </span><span class="category"><a href="/categories/js/">js</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#模块化的萌芽"><span class="toc-number">1.</span> <span class="toc-text">模块化的萌芽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJS"><span class="toc-number">2.</span> <span class="toc-text">CommonJS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用"><span class="toc-number">2.1.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Browserify"><span class="toc-number">2.1.1.</span> <span class="toc-text">Browserify</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实践"><span class="toc-number">2.2.</span> <span class="toc-text">实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMD"><span class="toc-number">3.</span> <span class="toc-text">AMD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#requireJS"><span class="toc-number">3.1.</span> <span class="toc-text">requireJS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD"><span class="toc-number">4.</span> <span class="toc-text">CMD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AMD与CMD区别"><span class="toc-number">4.1.</span> <span class="toc-text">AMD与CMD区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UMD"><span class="toc-number">5.</span> <span class="toc-text">UMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6模块化"><span class="toc-number">6.</span> <span class="toc-text">ES6模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-1"><span class="toc-number">6.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与CommonJS的区别"><span class="toc-number">6.2.</span> <span class="toc-text">与CommonJS的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环加载"><span class="toc-number">6.3.</span> <span class="toc-text">循环加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="post-content"><p>当代码量大到一定程度时，模块化编程可以帮助我们更好的管理我们的代码</p>
<ul>
<li>避免全局污染和代码冲突</li>
<li>更好地实现代码复用</li>
<li>便于代码的维护和管理，以及后期的升级</li>
<li>异步的模块化规范可以</li>
</ul>
<h3 id="模块化的萌芽"><a href="#模块化的萌芽" class="headerlink" title="模块化的萌芽"></a>模块化的萌芽</h3><ul>
<li>函数</li>
<li>面向对象</li>
<li>立即执行函数</li>
<li>放大模式</li>
</ul>
<p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　<span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</div><div class="line">　　　　mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">　　　　　　<span class="comment">//...</span></div><div class="line">　　　　&#125;;</div><div class="line">　　　　<span class="keyword">return</span> mod;</div><div class="line">　　&#125;)(module1);</div></pre></td></tr></table></figure></p>
<p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p>
<ul>
<li>宽放大模式</li>
</ul>
<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　<span class="keyword">var</span> module1 = ( <span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</div><div class="line">　　　　<span class="comment">//...</span></div><div class="line">　　　　<span class="keyword">return</span> mod;</div><div class="line">　　&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li>输出全局变量</li>
</ul>
<p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</div><div class="line">　　　　<span class="comment">//...</span></div><div class="line">　　&#125;)(jQuery, YAHOO);</div></pre></td></tr></table></figure></p>
<p>接下来介绍一些已有的模块化规范</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>CommonJS不适合用于浏览器环境，但对服务端不是问题，所有的模块都存放在本地硬盘，可以<strong>同步</strong>加载完成，等待时间只是硬盘读取时间。但对于浏览器，所有模块都存放在服务器端，等待时间取决于网速，浏览器可能处于“假死”状态。<br>而Node.js就是CommonJS规范的一个实现</p>
<p>浏览器不兼容CommonJS的根本原因，在于缺少了四个NodeJS环境变量</p>
<ul>
<li>module</li>
<li>exports</li>
<li>require</li>
<li>global</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>模块引用：require，用来引用外部模块</li>
<li>模块定义：exports，到处当前模块的方法或变量唯一导出口</li>
<li>模块标识：module，模块本身</li>
</ul>
<p>npm 的模块都是 JavaScript 语言写的，但浏览器用不了，因为不支持 CommonJS 格式。要想让浏览器用上这些模块，必须转换格式。</p>
<h5 id="Browserify"><a href="#Browserify" class="headerlink" title="Browserify"></a>Browserify</h5><p><strong>Browserify</strong>是CommonJS格式转换的工具<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm <span class="keyword">install </span><span class="keyword">browserify </span>-g</div></pre></td></tr></table></figure></p>
<p>使用命令将main.js转为浏览器可用的格式，compli.js的代码就可以直接在浏览器运行<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$browserify</span> main<span class="selector-class">.js</span> &gt; compli.js</div></pre></td></tr></table></figure></p>
<p>为了看清楚browserify到底做了什么，安装<strong>brower-unpack</strong><br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm <span class="keyword">install </span><span class="keyword">browser-unpack </span>-g</div></pre></td></tr></table></figure></p>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><ul>
<li>NodeJS是CommonJS的实现规范</li>
<li>Webpack也是以CommonJS的形式来写</li>
<li>npm也是CommonJS的一种实践</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html" target="_blank" rel="external">参考链接</a></p>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>Asynchronous Module Definition</p>
<p>异步模块定义，AMD采用异步加载模块，模块的加载不影响他后面语句的执行。所有依赖这个模块的语句都定义一个回调函数，等到加载完成之后，这个回调函数才会运行</p>
<p>先定义所有依赖，然后再加载完成后的回调函数中执行</p>
<p>使用define方法定义模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">define(<span class="string">"myModel"</span>,</div><div class="line">       [<span class="string">"foo"</span>,<span class="string">"bar"</span>],</div><div class="line">       <span class="function"><span class="keyword">function</span>(<span class="params">foo,bar</span>)</span>&#123;</div><div class="line">           <span class="keyword">var</span> myModel = &#123;</div><div class="line">               <span class="keyword">do</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">                   <span class="built_in">console</span>.log(<span class="string">"Yag"</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;;</div><div class="line">        <span class="keyword">return</span> myModel;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它的要求两个参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">require</span>([<span class="built_in">module</span>],callback)</div><div class="line"></div><div class="line"><span class="comment">//第一个参数是一个数组，里面的成员就是要加载的模块</span></div><div class="line"><span class="comment">//第二个参数callback，则是加载成功之后的回调函数</span></div><div class="line"></div><div class="line"><span class="built_in">require</span>([<span class="string">'math'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</div><div class="line">    math.add(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="requireJS"><a href="#requireJS" class="headerlink" title="requireJS"></a>requireJS</h4><p>RequireJS是AMD比较广泛的实现</p>
<p>解决问题：实现js文件的异步加载，避免网页失去响应；管理模块之间的依赖性，便于代码的编写和维护</p>
<p>使用：官网下载，引入文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script src =<span class="string">"js/require.js"</span>  defer <span class="keyword">async</span>=<span class="string">"true"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">为了不因为加载这个文件，也可能造成网页失去响应，添加两个属性</div><div class="line"><span class="keyword">async</span>:表明文件需要异步加载，避免网页失去响应</div><div class="line">defer：兼容IE</div><div class="line"></div><div class="line">接下来加载自己的代码文件</div><div class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line"></div><div class="line">data-main:指定网页程序的主模块，即入口文件。在上例中就是JS目录下面的main.js，这个文件会第一个被</div><div class="line"><span class="built_in">require</span>.js加载。由于<span class="built_in">require</span>.js默认的文件后缀名时js，可以吧main.js简写成main</div></pre></td></tr></table></figure>
<p>主模块的写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'underscore'</span>, <span class="string">'backbone'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$, _, Backbone</span>)</span>&#123;</div><div class="line">　　　　<span class="comment">// some code here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>模块的加载：对于上面的<code>&#39;jquery&#39;, &#39;underscore&#39;, &#39;backbone&#39;</code>require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。使用<code>require.config()</code>方法，我们可以对模块的加载行为进行自定义require.config()就写在主模块的头部，参数就是一个对象，这个对象的paths属性指定各个模块的加载路径</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">require</span><span class="selector-class">.config</span>(&#123;</div><div class="line">  <span class="attribute">baseUrl</span>:<span class="string">"js/lib"</span></div><div class="line">   <span class="attribute">paths</span>:&#123;</div><div class="line">       <span class="string">"jquery"</span>:<span class="string">"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min"</span>",</div><div class="line">       <span class="string">"underscore"</span>:<span class="string">"jq/underscore.min"</span>, <span class="comment">//js/lib/jq/underscore.min</span></div><div class="line">       <span class="string">"backbone"</span>:<span class="string">"backbone.min"</span></div><div class="line">   &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//如果不设置默认路径，则默认是data-main的所处目录</span></div></pre></td></tr></table></figure>
<p>模块定义：采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义math模块</span></div><div class="line"><span class="comment">//math.js</span></div><div class="line"></div><div class="line"><span class="comment">//math模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，</span></div><div class="line">指明该模块的依赖性，当<span class="built_in">require</span>()函数加载上面这个模块的时候，就会先加载myLib.js文件</div><div class="line">define([<span class="string">'myLib'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> x+y;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        add:add</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//加载</span></div><div class="line"><span class="comment">//main.js</span></div><div class="line"><span class="built_in">require</span>([<span class="string">'math'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</div><div class="line">   alter(math.add(<span class="number">1</span>,<span class="number">1</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>实现AMD规范的库还有：curl.js</p>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<p>require.js还可以加载一些非AMD规范的库，但在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">参考链接</a></p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>Common Module Definition</p>
<p>通用模块定义，就像AMD有requireJS一样，CMD有SeaJS</p>
<p>CMD加载完某个模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。</p>
<p>如何使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/seajs/3.0.2/sea.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="actionscript">	seajs.use(<span class="string">'./main'</span>)  <span class="comment">//引入主文件，注意路径，默认路径是SeaJS所处目录</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>定义模块,CMD推崇一个模块一个文件，经常用文件作为模块id，由于推崇<strong>就近依赖</strong>，所以不像AMD一样在define参数中写依赖，而是通过require在factory添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义模块 myModule.js</span></div><div class="line"><span class="comment">//define(id,deps,factory)</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>（<span class="title">require</span>,<span class="title">exports</span>,<span class="title">module</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>);</div><div class="line">    $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id)</span></div><div class="line"><span class="comment">//exports 是一个对象，用来向外提供模块接口</span></div><div class="line"><span class="comment">//module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</span></div></pre></td></tr></table></figure>
<p>引用模块，SeaJS通过seajs.use()来设置，在SeaJS在下载完成后，自动加载入口模块</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//加载模块，myModule.js为模块id</span></div><div class="line">seajs.<span class="keyword">use</span>([<span class="string">'myModule.js'</span>],<span class="function"><span class="keyword">function</span><span class="params">(my)</span></span>&#123;</div><div class="line">    ..</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="AMD与CMD区别"><a href="#AMD与CMD区别" class="headerlink" title="AMD与CMD区别"></a>AMD与CMD区别</h4><p>CommonJS和AMD都是为解决JS模块化的规范API，CommonJS更适合于Server端，而AMD基本是用于浏览器，CMD和AMD都是CommonJS的一种规范的实现定义</p>
<ol>
<li>语法上的差距</li>
</ol>
<ul>
<li>CMD推崇<strong>就近依赖</strong>，定义一个模块的时候不需要声明依赖模块，在需要的时候require就可以了。</li>
<li>AMD推崇<strong>依赖前置</strong>， 定义模块的时候需要声明依赖模块，并以形参的方式引入factory中。</li>
</ul>
<p>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AMD 方式定义模块</span></div><div class="line">define([<span class="string">'dep1'</span>,<span class="string">'dep2'</span>],fucntion(dep1,dep2)&#123;</div><div class="line">    <span class="comment">//内部职能使用制定的模块</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//CMD</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span>&#123;</div><div class="line">   <span class="comment">//此处如果需要某XX模块，可以引入</span></div><div class="line">    <span class="keyword">var</span> xx = <span class="built_in">require</span>(<span class="string">'XX'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>所依赖模块的执行时机不同<br>对于requireJS是异步加载的，SeaJS是同步加载的，这样的说法是错误的，用于浏览器加载应该都是异步加载，AMD和CMD最大的区别是<strong>对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同</strong></li>
</ol>
<ul>
<li>CMD定义一个模块的时候不需要立即执行依赖模块但会提前加载，在需要的时候require后执行后</li>
<li>AMD 定义模块的时候声明依赖模块后立即执行依赖模块，并以形参的方式引入factory中。</li>
</ul>
<h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>既然CommonJs和AMD风格一样流行，似乎缺少一个统一的规范。所以人们产生了这样的需求，希望有支持两种风格的“通用”模式，于是通用模块规范（UMD）诞生了。</p>
<p>UMD的实现很简单，先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。</p>
<p>再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开到全局（window或global）。</p>
<p>一般很少提及，作为了解</p>
<h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>ES6 的模块自动采用<strong>严格模式</strong>，不管你有没有在模块头部加上”use strict”;</p>
<p>export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<p>export命令和import命名只能写在模块的顶层，不能写在条件代码中</p>
<p>export default  在一个模块中只能用一次<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> lastName = <span class="string">'dsf'</span>;</div><div class="line"><span class="keyword">export</span> &#123;lastName&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'44'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">	v1 <span class="keyword">as</span> streamv1</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;firsrtName&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">'./profile'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> （） </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</div></pre></td></tr></table></figure></p>
<p>import语句会执行所加载的模块，多次重复执行同义句import语句，加载多次，只会执行一次，而不会执行多次</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// CommonJS模块</span></div><div class="line"><span class="keyword">let</span> &#123; stat, <span class="keyword">exists</span>, readFile &#125; = require(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> <span class="number">_f</span>s = require(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">let</span> stat = <span class="number">_f</span>s.stat;</div><div class="line"><span class="keyword">let</span> <span class="keyword">exists</span> = <span class="number">_f</span>s.<span class="keyword">exists</span>;</div><div class="line"><span class="keyword">let</span> readfile = <span class="number">_f</span>s.readfile;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ES6模块</span></div><div class="line"><span class="keyword">import</span> &#123; stat, <span class="keyword">exists</span>, readFile &#125; from <span class="string">'fs'</span>;</div><div class="line">ES<span class="number">6</span>不加载fs的其他方法</div></pre></td></tr></table></figure>
<p>从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，使得编译是就能确定模块化的依赖关系，以及输入和输出的变量，效率要比 CommonJS 模块的加载方式高。而CommonJS和AMD模块，只能在运行时确定这些东西</p>
<h4 id="与CommonJS的区别"><a href="#与CommonJS的区别" class="headerlink" title="与CommonJS的区别"></a>与CommonJS的区别</h4><p>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用</p>
<p>CommonJS模块是运行时加载，ES6模块是编译是输出接口（CommonJS加载的是一个对象，该对象只有在脚本运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</p>
<p>export通过接口，输出的是同一个值。不同的脚本加载接口，得到的都是同样的实例。</p>
<h4 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h4><ol>
<li><p>CommonJS<br>CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
</li>
<li><p>ES6 模块的循环加载<br>ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。一旦出现某个模块被”循环加载”，默认接口已经存在，跳过import语句，往下执行</p>
</li>
</ol>
<p><a href="http://es6.ruanyifeng.com/#docs/module-loader#ES6-模块与-CommonJS-模块的差异" target="_blank" rel="external">参考链接</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从模块化的发展历程来看，最先出现的是源自nodejs的CommonJS,CommonJS在服务端运行时没问题的，所有的模块都存放在本地硬盘，可以同步加载完成，等待时间只是硬盘读取时间。但对于浏览器，所有模块都存放在服务器端，等待时间取决于网速，浏览器可能处于“假死”状态。<br>进而AMD出现了，AMD的思想正如其名，异步加载所需的模块，然后在回调函数中执行主逻辑，实现js文件的异步加载，避免网页失去响应。<br>后起之秀CMD，相比AMD的前置依赖，CMD推崇就近依赖，定义一个模块的时候不需要立即执行依赖模块但会提前加载，在需要的时候require后执行后<br>最后，在ES6中，终于对前端模块化做了补充，虽然目前浏览器还不支持ES6模块，有了语言层级原生支持，ES6模块可以说是未来主流的模块化</p>
<p><a href="http://web.jobbole.com/83761/" target="_blank" rel="external">参考链接</a></p>
</div><div class="tags"><a href="/tags/前端工程化/">前端工程化</a></div><div class="post-nav"><a href="/2018/01/07/abou-https/" class="pre">浅析HTTPS</a><a href="/2017/10/16/type-change/" class="next">js的类型转换</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/前端工程化/" style="font-size: 15px;">前端工程化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/07/abou-https/">浅析HTTPS</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/module/">模块化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/16/type-change/">js的类型转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/06/hello-world/">开篇</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Chennnn.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>