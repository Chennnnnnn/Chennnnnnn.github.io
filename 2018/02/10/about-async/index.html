<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JavaScript的异步编程 | Chennnn</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript的异步编程</h1><a id="logo" href="/.">Chennnn</a><p class="description">在安静中，不慌不忙地坚强</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript的异步编程</h1><div class="post-meta">Feb 10, 2018<span> | </span><span class="category"><a href="/categories/js/">js</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript的异步机制"><span class="toc-number">1.</span> <span class="toc-text">JavaScript的异步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS的单线程"><span class="toc-number">1.1.</span> <span class="toc-text">JS的单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步任务与异步任务"><span class="toc-number">1.2.</span> <span class="toc-text">同步任务与异步任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件循环"><span class="toc-number">1.3.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript的异步编程方案"><span class="toc-number">2.</span> <span class="toc-text">JavaScript的异步编程方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#回调函数"><span class="toc-number">2.1.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发布-订阅模式"><span class="toc-number">2.2.</span> <span class="toc-text">发布/订阅模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异步API"><span class="toc-number">2.2.1.</span> <span class="toc-text">异步API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三方库"><span class="toc-number">2.2.2.</span> <span class="toc-text">第三方库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义实现"><span class="toc-number">2.2.3.</span> <span class="toc-text">自定义实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-number">2.3.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JQuery之Promise"><span class="toc-number">2.3.1.</span> <span class="toc-text">JQuery之Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6之Promise"><span class="toc-number">2.3.2.</span> <span class="toc-text">ES6之Promise</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator"><span class="toc-number">2.4.</span> <span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async-Await"><span class="toc-number">2.5.</span> <span class="toc-text">Async/Await</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步编程的难点"><span class="toc-number">3.</span> <span class="toc-text">异步编程的难点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#异步并行"><span class="toc-number">3.1.</span> <span class="toc-text">异步并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步串行"><span class="toc-number">3.2.</span> <span class="toc-text">异步串行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常处理"><span class="toc-number">3.3.</span> <span class="toc-text">异常处理</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="JavaScript的异步机制"><a href="#JavaScript的异步机制" class="headerlink" title="JavaScript的异步机制"></a>JavaScript的异步机制</h1><h2 id="JS的单线程"><a href="#JS的单线程" class="headerlink" title="JS的单线程"></a>JS的单线程</h2><p>对于单线程的JavaScript，如果所有的任务都是同步任务，那么执行耗时较长的I/O操作时，会阻塞到后面的任务，在这段时间内JS不能处理其他任务，后面的任务都会被阻塞，此时的页面交互是非常不友好的。</p>
<p>为了解决这个问题，JS将任务分为同步任务与异步任务</p>
<h2 id="同步任务与异步任务"><a href="#同步任务与异步任务" class="headerlink" title="同步任务与异步任务"></a>同步任务与异步任务</h2><p>所谓同步任务（这里所说的任务可以简单理解为函数）就是根据代码从上到下，一次任务接着一个任务执行，后面的任务需要等待前一个任务执行完毕才开始执行</p>
<p>而异步任务（例如I/O操作）会有一个或多个回调函数，任务完成后执行回调函数。而后一个任务无需等待前一个任务执行完毕，在前一个任务开始之后就可以执行了</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p><strong>任务队列</strong> ： 异步任务完成时会将相关回调添加到任务队列中。</p>
<p>在进程启动时，JS会创建一个类似于while(1)的循环，每一次循环就是查看任务队列中是否有事件待处理。有则处理事件及其相关回调函数，没有则进入下个循环。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上文提到的JavaScript单线程的是指JavaScript执行在单线程中罢了，内部完成异步任务的另有线程池，除了用户的代码无法并行执行外，所有的异步任务则是可以并行起来的</p>
<p>在整个过程中，<code>JavaScript主线程</code>解析到同步任务被立即执行，遇到异步任务会开启另一个线程去管理，等到异步任务完成时会将回调函数添加到<code>任务队列</code>中，等待<code>事件循环</code>调用（不同任务队列的优先级不同）</p>
<h1 id="JavaScript的异步编程方案"><a href="#JavaScript的异步编程方案" class="headerlink" title="JavaScript的异步编程方案"></a>JavaScript的异步编程方案</h1><p><strong>异步函数</strong></p>
<p>首先明确什么是异步函数：一个函数若称为异步函数，则这个函数会导致在未来某个时间<code>运行另一个函数</code>，后者取自于<code>事件队列</code>;异步函数有一下两种：</p>
<ol>
<li>JavaScript运行环境提供的异步API（I/O函数，计时器），它们触发的回调函数的时间不为用户代码所控制</li>
<li>由其他第三方库封装的”异步函数”，通常这些函数中会调用原生的异步API</li>
</ol>
<hr>
<p>以下方案只是通过代码对异步任务及其回调函数的处理方案；实质上与异步任务无直接关系，只是作为一种设计模式，编程思想存在，也<code>可以用于同步</code></p>
<ul>
<li>回调函数</li>
<li>发布/订阅 ：事件监听</li>
<li>Promise </li>
<li>Generator(ECMAScript6)</li>
<li>await,async(ECMAScript7)</li>
</ul>
<p>若没有调用异步API，回调函数是不会添加到任务队列中,即为同步任务</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>将回调函数作为参数，在执行某些操作之后调用</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//第三方库实现，实质为同步任务</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span><span class="params">(callback)</span></span>&#123;  </div><div class="line">    <span class="comment">// do something</span></div><div class="line">    callback();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//使用异步API，bar将会添加到任务队列</span></div><div class="line"><span class="keyword">var</span> foo1 = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> </span>&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">    setTimeout(callback)</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(bar);</div><div class="line">foo1(bar);</div></pre></td></tr></table></figure>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h2><p>对于一些在未来可能触发的异步任务，一般会采用发布/订阅模式来调用回调函数</p>
<p>回调函数作为一个订阅者，订阅异步任务，异步任务完成后发布消息，回调函数接收到消息后执行操作</p>
<h3 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h3><p>DOM事件，nodeJS中的EvenEmitter对象</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">document</span><span class="selector-class">.getElementById</span>(<span class="string">"myBtn"</span>)<span class="selector-class">.addEventListener</span>(<span class="string">"click"</span>, myFunction);</div></pre></td></tr></table></figure>
<h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>JQuery的bind方法，内部调用了异步API</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(link)</div><div class="line"> .<span class="built_in">bind</span>(<span class="string">'click'</span>,clickHander)</div><div class="line"> .<span class="built_in">bind</span>(<span class="string">'click'</span>,clickHander2);</div></pre></td></tr></table></figure>
<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><p>用一个数组保存已订阅的回调函数，当事件触发时，依次执行。订阅时，将该函数添加到数组中，退订时，就将该函数从数组中删除</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PubSub = &#123;&#125;;</div><div class="line"><span class="comment">// 用于储存事件队列</span></div><div class="line"><span class="keyword">var</span> queue = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 订阅接口</span></div><div class="line">PubSub<span class="variable">.on</span> = <span class="keyword">function</span>(<span class="keyword">event</span>, cb) &#123;</div><div class="line">  <span class="keyword">if</span> (!queue[<span class="keyword">event</span>]) &#123;</div><div class="line">    queue[<span class="keyword">event</span>] = [];</div><div class="line">  &#125;</div><div class="line">  queue[<span class="keyword">event</span>]<span class="variable">.push</span>(cb);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 退订接口</span></div><div class="line">PubSub<span class="variable">.off</span> = <span class="keyword">function</span>(<span class="keyword">event</span>, cb) &#123;</div><div class="line">  <span class="keyword">var</span> currentEvent = queue[<span class="keyword">event</span>];</div><div class="line">  <span class="keyword">var</span> len = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (currentEvent) &#123;</div><div class="line">    len = currentEvent<span class="variable">.length</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">      <span class="keyword">if</span> (currentEvent[i] === cb) &#123;</div><div class="line">        currentEvent<span class="variable">.splice</span>(i, <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 发布接口</span></div><div class="line">PubSub<span class="variable">.emit</span> = <span class="keyword">function</span>(<span class="keyword">event</span>) &#123;</div><div class="line">  <span class="keyword">var</span> currentEvent = queue[<span class="keyword">event</span>];</div><div class="line">  <span class="keyword">if</span> (currentEvent) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; currentEvent<span class="variable">.length</span>; i++) &#123;</div><div class="line">      currentEvent[i]();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>对于异步任务，我们需要处理的不单单只是对异步任务成功完成的操作，有时还需要对它的成功，失败，或是无论成功或失败都要执行相应的动作</p>
<p>Promise不仅使得为任务的不同结果添加回调更为方便，还解决了直接使用回调函数造成回调地狱的问题（下文会介绍），它相当于一个接口，随时随地添加回调，并允许同一个事件绑定多个回调</p>
<h3 id="JQuery之Promise"><a href="#JQuery之Promise" class="headerlink" title="JQuery之Promise"></a>JQuery之Promise</h3><p>JQuery中的Promise可以说是ES6 Promise的前生</p>
<p>JQuery 1.5中引入Promise</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//JQ <span class="number">1.4</span></div><div class="line">$.get(<span class="string">'/mydata'</span>, &#123;</div><div class="line"> success: onSuccess,</div><div class="line"> <span class="keyword">failure</span>: onFailure,</div><div class="line"> always: onAlways</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//JQ <span class="number">1.5</span></div><div class="line">var <span class="keyword">promise</span> <span class="built_in">=</span> $.Deferred();</div><div class="line"><span class="keyword">promise</span>.done(onSuccess);</div><div class="line"><span class="keyword">promise</span>.<span class="built_in">fail</span>(onFailure);</div><div class="line"><span class="keyword">promise</span>.always(onAlways);</div><div class="line"><span class="keyword">promise</span>.resolve();</div></pre></td></tr></table></figure>
<blockquote>
<p>JQuery中的Promise对象与Deferred对象 </p>
<p>Deferred是特殊的Promise，deferred比promise多了一些关键的特性，可以直接触发。</p>
<p>Deferred对象通过promise()方法生成的promise对象只是Deferred对象的副本，它们分享着同样的回调，同样的state。事实上，jQuery给出的只不过是同一个对象。对一个纯promise对象再调用promise方法，产生的只不过是一个指向相同对象的引用。</p>
</blockquote>
<h3 id="ES6之Promise"><a href="#ES6之Promise" class="headerlink" title="ES6之Promise"></a>ES6之Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  (<span class="comment">// 异步操作的代码</span></div><div class="line">   <span class="comment">// 作为回调函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">            resolve(value);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            reject(error);</div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">  <span class="comment">//异步操作的代码)</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>,value);</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.dir(<span class="string">'error'</span>,error);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>ES6的Promise是一个异步API，与JQuery实现的Promise不同的是，ES6中由then方法指定的回调函数必须得等主线程的所有同步任务执行完了才会被调用，也就是说Promise规定then中的回调采用异步任务的方式来调用。</strong></p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 函数是 ES6 标准引入的新特性，旨在提供一类完全不同于以往异步编写方式的解决方案</p>
<p>Generator 函数是一个状态机，封装了多个内部状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</div><div class="line">      resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</div><div class="line">  <span class="built_in">console</span>.log(f1.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><p>ES7标准引入的 Async/Await 语法，本质上是Generator的语法糖</p>
<p>将上文Generator函数改写成 async函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</div><div class="line">  <span class="built_in">console</span>.log(f1.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</p>
<p>每一个方案都是建立在前一个方案的基础上，可以说是对前一个方案的优化</p>
<h1 id="异步编程的难点"><a href="#异步编程的难点" class="headerlink" title="异步编程的难点"></a>异步编程的难点</h1><ul>
<li>异步并行（回调地狱）</li>
<li>异步串行（回调地狱）</li>
<li>异常处理</li>
</ul>
<h2 id="异步并行"><a href="#异步并行" class="headerlink" title="异步并行"></a>异步并行</h2><p>为了在多个异步任务执行完成后执行回调函数，可能会出现如下代码块</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">connection.query(sql1, <span class="function"><span class="keyword">function</span><span class="params">(data1)</span></span>&#123;</div><div class="line">    connection.query(sql2, <span class="function"><span class="keyword">function</span><span class="params">(data2)</span></span>&#123;</div><div class="line">        connection.query(sql3, <span class="function"><span class="keyword">function</span><span class="params">(data3)</span></span>&#123;</div><div class="line">            callback(data1,data2,data3);</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>使用Promise，Async函数都需要先用Promise对象进行封装</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> query = <span class="function">(<span class="params">sql</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        connection.query(sql, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                reject(err);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                resolve(results);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用Promise</span></div><div class="line"><span class="built_in">Promise</span>.all([query(sql1),query(sql2),query(sql3)])</div><div class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</div><div class="line">    callback(&#123;..data&#125;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//使用Async函数</span></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> data1 = <span class="keyword">await</span> query(sql1);</div><div class="line">    <span class="keyword">let</span> data2 = <span class="keyword">await</span> query(sql2);</div><div class="line">    <span class="keyword">let</span> data3 = <span class="keyword">await</span> query(sql3);</div><div class="line">    callback(data1,data2,data3);</div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
<p>Promise 提供了Promise.all()方法，接受一个或多个promsie（以数组方式传递），返回一个新promise，该promise状态取决于传入的参数中的所有promsie的状态</p>
<p>Async 同样需要借助 Promise 对象实现，使得代码风格更像同步代码</p>
<p>两种实现方式相比，更推荐使用Promise.all()，因为使用Async函数，第二个<code>query(sql2)</code>需要等到<code>query(sql1)</code>完成才会执行，这就又回到了文章开头所说的后面任务（async函数内）会被阻塞的问题了,实际上是使用串行的方法</p>
<h2 id="异步串行"><a href="#异步串行" class="headerlink" title="异步串行"></a>异步串行</h2><p>在node中，常常会根据I/O操作的结果判断下一步的操作</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">connection.<span class="keyword">query</span>(sql, (<span class="keyword">err</span>, results) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</div><div class="line">    console.<span class="built_in">log</span>(<span class="keyword">err</span>)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (results.length)&#123;</div><div class="line">    connection.<span class="keyword">query</span>(sql2, (<span class="keyword">err</span>, results) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</div><div class="line">            console.<span class="built_in">log</span>(<span class="keyword">err</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            doSomething(results)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上述代码也会形成回调地狱，是用Promise或Async可以更好地地组织代码，特别是Async函数，还可以方便地实现串行与并行交替</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//封装Promise</span></div><div class="line"><span class="keyword">const</span> query = <span class="function">(<span class="params">sql</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        connection.query(sql, (err, results) =&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                reject(err);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                resolve(results);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用Promise</span></div><div class="line"></div><div class="line">query(sql)</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (result.length) &#123;</div><div class="line">      <span class="keyword">return</span> query(sql2)</div><div class="line">    &#125; </div><div class="line">&#125;)</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (result.length) &#123;</div><div class="line">      <span class="keyword">return</span> query(sql3)</div><div class="line">    &#125; </div><div class="line">&#125;)</div><div class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>,err)</div><div class="line">&#125;) </div><div class="line"></div><div class="line"><span class="comment">//使用Async函数 </span></div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">	<span class="keyword">let</span> result1 = <span class="keyword">await</span> query(<span class="number">1</span>)</div><div class="line">	<span class="keyword">let</span> result2;</div><div class="line">	<span class="keyword">let</span> result3;</div><div class="line">    <span class="keyword">if</span> (result1.length) &#123;</div><div class="line">	  result2 = <span class="keyword">await</span> query(result1)</div><div class="line">	&#125;  </div><div class="line">	<span class="keyword">if</span> (result2 &amp;&amp; result2.length) &#123;</div><div class="line">		result3 = <span class="keyword">await</span> query(result2)</div><div class="line">	&#125;  </div><div class="line">	<span class="built_in">console</span>.log(result3); </div><div class="line">&#125;)().catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>,err)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>一般尝试对异步方法进行<code>try/catch</code>操作只能捕获当次事件循环的异常，对callback执行时抛出的异常捕获不到<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="string">'err'</span></div><div class="line">    &#125;,<span class="number">0</span>)</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Promise的异常处理</strong><br>使用Promise对于异常的处理较为方便</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promsie = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="string">'err'</span>; <span class="comment">//抛出异常</span></div><div class="line">    resolve(<span class="string">'success'</span>)  <span class="comment">//不会执行</span></div><div class="line">&#125;)</div><div class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>,err)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<p>上面代码还可以写成<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promsie = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    reject(<span class="string">'err'</span>); <span class="comment">//抛出异常</span></div><div class="line">    resolve(<span class="string">'success'</span>)  <span class="comment">//不会执行</span></div><div class="line">&#125;)</div><div class="line">.then(<span class="literal">null</span>,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>,err)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>无论是<code>throw &#39;err&#39;</code>还是<code>reject(&#39;err&#39;)</code>都会抛出异常，then()方法的第二个参数是可选的，一般使用<code>catch方法捕获异常</code>，会使代码比较直观</p>
<p><strong>Async函数的异常处理</strong></p>
<p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f()</div><div class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</div><div class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</div></pre></td></tr></table></figure>
<p>防止出错的方法，也是将其放在try…catch代码块之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">const</span> val1 = <span class="keyword">await</span> firstStep();</div><div class="line">    <span class="keyword">const</span> val2 = <span class="keyword">await</span> secondStep(val1);</div><div class="line">    <span class="keyword">const</span> val3 = <span class="keyword">await</span> thirdStep(val1, val2);</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Final: '</span>, val3);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考链接</p>
<p><a href="http://blog.codingplayboy.com/2017/05/10/async_promise/#Promisealliterable" target="_blank" rel="external">JavaScript异步与Promise实现</a></p>
<p><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="external">ECMAScript 6 入门</a></p>
</div><div class="tags"></div><div class="post-nav"><a href="/2018/01/07/abou-https/" class="next">浅析HTTPS</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/前端工程化/" style="font-size: 15px;">前端工程化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/02/10/about-async/">JavaScript的异步编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/07/abou-https/">浅析HTTPS</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/module/">模块化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/16/type-change/">js的类型转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/06/hello-world/">开篇</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Chennnn.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>